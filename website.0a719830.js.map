{"mappings":"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","sources":["src/index.js"],"names":["phrases","el","fx","counter","TextScrambler","$b350cd9db4549ae05bfb23b905ede80$var$_classCallCheck","this","chars","update","bind","newText","_this","oldText","innerText","length","Math","max","promise","Promise","resolve","queue","i","from","to","start","floor","random","end","push","cancelAnimationFrame","frameRequest","frame","output","complete","n","_this$queue$i","char","randomChar","concat","innerHTML","requestAnimationFrame","Nav","func","limit","lastFunc","lastRan","navHeight","document","querySelector","getBoundingClientRect","height","mainNavLinks","querySelectorAll","window","addEventListener","fromTop","scrollY","prevSectionEnd","hash","offsetTop","link","section","sectionEnd","offsetHeight","classList","add","remove","context","args","arguments","clearTimeout","setTimeout","Date","now","apply","next","setText","then"],"version":3,"file":"website.0a719830.js.map","sourcesContent":["class TextScrambler {\n    constructor(el) {\n        this.el = el\n        this.chars = '!<>-_\\\\/[]{}â€”=+*^?#________'\n        this.update = this.update.bind(this)\n    }\n\n    setText(newText) {\n        const oldText = this.el.innerText\n        const length = Math.max(oldText.length, newText.length)\n        const promise = new Promise((resolve) => this.resolve = resolve)\n        this.queue = []\n        for (let i = 0; i < length; i++) {\n            const from = oldText[i] || ''\n            const to = newText[i] || ''\n            const start = Math.floor(Math.random() * 40)\n            const end = start + Math.floor(Math.random() * 40)\n            this.queue.push({ from, to, start, end })\n        }\n        cancelAnimationFrame(this.frameRequest)\n        this.frame = 0\n        this.update()\n        return promise\n    }\n\n    update() {\n      let output = ''\n      let complete = 0\n      for (let i = 0, n = this.queue.length; i < n; i++) {\n        let { from, to, start, end, char } = this.queue[i]\n        if (this.frame >= end) {\n            complete++\n            output += to\n        } else if (this.frame >= start) {\n            if (!char || Math.random() < 0.28) {\n                char = this.randomChar()\n                this.queue[i].char = char\n            }\n            output += `<span class=\"dud\">${char}</span>`\n        } else {\n            output += from\n        }\n      }\n      this.el.innerHTML = output\n      if (complete === this.queue.length) {\n            this.resolve()\n      } else {\n            this.frameRequest = requestAnimationFrame(this.update)\n            this.frame++\n      }\n    }\n\n    randomChar() {\n        return this.chars[Math.floor(Math.random() * this.chars.length)]\n    }\n}\n\nconst throttle = (func, limit) => {\n    let lastFunc;\n    let lastRan;\n    return function() {\n        const context = this;\n        const args = arguments;\n        if (!lastRan) {\n            func.apply(context, args);\n            lastRan = Date.now();\n        } else {\n            clearTimeout(lastFunc);\n            lastFunc = setTimeout(function() {\n                if ((Date.now() - lastRan) >= limit) {\n                    func.apply(context, args);\n                    lastRan = Date.now();\n                }\n            }, limit - (Date.now() - lastRan));\n        }\n    }\n}\n\nclass Nav {\n    constructor() {\n        const navHeight = document.querySelector(\".nav\").getBoundingClientRect().height;\n        const mainNavLinks = document.querySelectorAll(\".nav .sections a\");\n\n        window.addEventListener(\"scroll\", throttle(() => {\n\n                const fromTop = window.scrollY;\n\n                let prevSectionEnd = document.querySelector(mainNavLinks[0].hash).offsetTop - navHeight\n                for (let i = 0; i < mainNavLinks.length; i++) {\n                    const link = mainNavLinks[i];\n                    \n                    const section = document.querySelector(link.hash);\n                    const sectionEnd = section.offsetTop - navHeight + section.offsetHeight\n\n                    if (\n                        prevSectionEnd <= fromTop &&\n                        sectionEnd > fromTop\n                    ) {\n                        link.classList.add(\"active\");\n                    } else {\n                        link.classList.remove(\"active\");\n                    }\n\n                    prevSectionEnd = sectionEnd\n                }\n            }, 100));\n    }\n}\n\n(function() {\n    const phrases = [\n        \"I'm a Software Engineer.\",\n        \"I love solving problems \",\n        \"and learning new things!\",\n    ]\n\n    const el = document.querySelector('.text')\n    const fx = new TextScrambler(el)\n\n    let counter = 0\n    const next = () => {\n        fx.setText(phrases[counter]).then(() => {\n            setTimeout(next, 800)\n        })\n        counter = (counter + 1) % phrases.length\n    }\n    \n    next()\n\n    new Nav()\n})();"]}